---
title: 《你不知道的JavaScript》笔记
date: 2022-08-29
tags: 
  - 读书笔记
  - JavaScript
categories: 
  - 读书笔记

---

原书分为上、中、下三册，文章末尾有下载链接。

<!-- more -->

<img src="/images/blog/你不知道的JavaScript.png" style="width:200px;margin:0 auto;display:block;">

## 上卷

### 作用域与闭包

文章从 js 的编译原理为入口，解释作用域。

js 语言的解析器是 V8引擎，浏览器中的解析器会实时的分析 js 的代码，相比其他语言，缺少了提前编译成字节码的步骤，所以引擎在解析 js 代码的时候会通过种种方法来对性能进行优化（例如 JIT[^1]、延迟编译、重编译等）

[^1]: 全称 Just In Time，可以简单的理解为：代码的解释器和编译器一起执行

在解析代码的过程中，必不可少的两个操作变量的步骤 LHS 和 RHS[^2]，相对应的一套取赋值规则引出了作用域概念。

[^2]: LHS 和 RHS 分别理解为赋值操作的左侧与右侧，左侧可以理解成取值、右侧可以理解成赋值

![V8引擎的JIT技术简述](/images/blog/V8引擎的JIT技术简述.jpg)

segmentfault文章：[V8引擎是如何工作的](https://segmentfault.com/a/1190000037435824)

#### 作用域

词法作用域就是代码的位置，

**注意**：`eval()` 函数 、`with()` 函数、`new Function()`都会影响识别作用域，并且会使代码性能有损失，所以一般使用较少。

---

函数函数作用域实际上就是两个大括号标签`{ ... }`中的代码。

当引擎读取到取值操作时，会一次按照大括号的层级，逐层向上查找是否有过定义（定义包含 var / let / const / function 等），直到全局作用域，如果还没有就抛出异常。

代码中需要注意尽量避免隐式的作用域的提升。

---

全局作用域作为所有作用域的根部级别出现。浏览器中是window，Node.js 中是 global。

#### 闭包

概念：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行。

理解关键字：函数套函数+外部可访问内部变量（一般都是外部函数返回内部函数，操作）=》闭包

闭包的特点：可以使用私有变量、避免过早的释放内存。

**注意**：闭包与内存泄露问题，除了老旧浏览器的bug以外，闭包不是引起内存泄漏的根本，根本问题一般出自开发者。

### this和对象原型

#### this

this的指向需要从**运行时**去理解，而不是编写时，不是代码位置。脑海中模拟代码的执行，查看函数调用时的位置、参数，以便于确认this的指向。

准确获得this指向的步骤如下：

1. 追溯调用栈（学习方法：在浏览器中打一次 debugger 一步步执行）就可以获得**当前函数的调用位置**
2. 查看调用位置使用那种形式绑定this：默认/显式绑定/隐式绑定
   1. 默认绑定：this 指向全局对象 `window`（定义函数为严格模式时：this 指向 undefined，调用时是否严格模式不影响）
   2. 隐式绑定：函数被绑定到对象下调用， this指向上一层（不是对象的根）
      1. 隐式丢失：函数被再次赋值给其他变量，this指向新的调用此变量时的环境
   3. 显式绑定：
      1. API绑定：bind / call / apply
      2. 实例化绑定：function / class => new
3. 绑定类型可能不唯一，显示会覆盖隐式
4. 特殊情况
   1. bind 传入了 `null` `undefined`，实际会应用默认绑定
   2. 软绑定：需要手动实现，如果绑定到了全局，就更改绑定到obj，代码如下
   3. 箭头函数：指向调用时绑定的对象上 且 箭头函数的this无法被修改（任何情况）

```JavaScript
// 软绑定
if (!Function.prototype.softBind) { 
  Function.prototype.softBind = function(obj) {
    var fn = this;
    // 捕获所有 curried 参数
    var curried = [].slice.call( arguments, 1 ); var bound = function() {
      return fn.apply((!this || this === (window || global)) ?
        obj : this,
        curried.concat.apply( curried, arguments )
      ); 
    };
    bound.prototype = Object.create( fn.prototype );
    return bound; 
  };
}
```

#### 对象与类

##### 属性描述符[ES5]

对象的属性新增了描述符，通过函数`Object.defineProperty(object, key, options)`控制，options支持 ：

1. writable：属性是否可编辑
2. configurable：描述符可修改，置为false时delete属性也会失效
3. enumerable：是否在枚举中出现
4. getter setter：操作 读/写 命令时，触发的监测回调

相关API：

- `Object.preventExtensions(obj)` 禁止后面再向对象添加新属性
- `Object.seals(obj)` 执行 Object.preventExtensions 并设置 configurable: false
- `Object.freeze(obj)` 执行 Object.seals 并设置 writable: false

##### 类的继承与钻石问题

继承：子类包含父类的属性、api等，子类修改属性不会影响父类。

由此引出一个问题，如果子类同时继承于多个父类（复杂的结构中继承的层级关系更高）并且多个父类中存在同名但功能不一致的方法，那么字类继承了哪个父类的这个方法？

JavaScript 为了解决这个问题，提出了 **混入** 的方式：

根据代码写法分为显式 / 隐式混入，原理一致，怎么实现都可以

```js
var A = {oh: function(){console.log('aa')}}
var B = {oh: function(){console.log('bb')}}
function mixin( sourceObj, targetObj ) {
  for (var key in sourceObj) {
    if (!(key in targetObj)) { // 只会在不存在的情况下复制 
      targetObj[key] = sourceObj[key];
    }else{
      var func = targetObj[key] // 先存一下，防止调用后死循环
      targetObj[key] = function(){
        sourceObj[key].call( targetObj ) // 执行 source 的部分
        func() // 执行 target 部分
      }
    }
  }
  return targetObj; 
}
var c = mixin(A, B)
c.oh()
// 打印结果：
// VM813:1 aa
// VM813:2 bb
```

关于mixin 可查看文章：[阮一峰 ES6入门 - mixin](https://github.com/ruanyf/es6tutorial/blob/3929f4f21148dcd2a10d2ebc722323a5dbd473f4/docs/mixin.md)

##### 行为委托与类即成的风格区别

首先需要确定的一点是，js中没有真实的类，都是用`prototype`去模拟实现的，即使到 ES6 中出现了 class ，但 class ，与其他语言中的类并不一致，不是真实的类，实际是`prototype`的语法糖。

```JavaScript
// js模拟类的继承
function Foo(who) { 
  this.me = who;
}
Foo.prototype.identify = function() {
  return "I am " + this.me; 
};
function Bar(who) { 
  Foo.call( this, who );
}
Bar.prototype = Object.create( Foo.prototype );
Bar.prototype.speak = function() {
  alert( "Hello, " + this.identify() + "." );
};
var b1 = new Bar( "b1" );
var b2 = new Bar( "b2" ); 
b1.speak();
b2.speak();

// 行为委托（对象关联）
Foo = {
  init: function(who) {
    this.me = who; 
  },
  identify: function() {
    return "I am " + this.me;
  } 
};
Bar = Object.create( Foo );
Bar.speak = function() {
  alert( "Hello, " + this.identify() + "." );
};
var b1 = Object.create( Bar );
b1.init( "b1" );
var b2 = Object.create( Bar );
b2.init( "b2" );
b1.speak();
b2.speak();
```

相比于类-继承的实现方式，该书更推荐使用对象-委托的形式来实现同样的功能，相比之下更简洁，更贴合js的设计理念。

当然这里不是否定类的形式，只是说我们还有别的途径去实现对应功能，毕竟类的形式的 ES6 的语法糖 class 也很简洁。

## 中卷

### 类型和语法

### 异步和性能

## 下卷

### 深入JS

### ES6与更新的版本

## End.总结

> 下载地址 [《你不知道的JavaScript》上卷](https://cloud.189.cn/t/UfYzu2nqQVRn) 访问码：z4xn
> 下载地址 [《你不知道的JavaScript》中卷](https://cloud.189.cn/t/RfEjMzJJnm2m) 访问码：qki4
> 下载地址 [《你不知道的JavaScript》下卷](https://cloud.189.cn/t/NNB7NfEFzmi2) 访问码：fw4h
