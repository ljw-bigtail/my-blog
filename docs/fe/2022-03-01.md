---
title: 面试题汇总
date: 2022-03-01
tags: 
  - 面试题
categories: 
  - 碎片
---

2022前端面试题搜集

<!--more-->

## HTML

### 如何理解HTML的语义化

根据内容的结构来选择合适的标签。
这样做对搜索引擎友好，seo效果较好；另外，语义化的代码可以让开发者更容易理解代码结构。

### script标签的defer和async都有哪些特点？

`<script>` 浏览器会立即加载并执行脚本，所以就阻塞了后续dom的执行 => 这就是推荐把script标签引用在dom的最后方
`<script defer>` 浏览器会立即加载脚本，且不会阻塞dom，等到文档全部加载完后再执行，DOMContentLoaded事件触发前执行
`<script async>` 浏览器会立即加载并脚本，且不会阻塞dom。即真正的异步加载

### iframe优缺点有哪些？

优点：

- 适合用来加载速度较慢的部分，不会影响主线的性能
- 可以实现跨子域通信
- 可以并行下载脚本
- 可以实现无刷新上传

缺点：

- iframe会阻塞onload事件
- 搜索引擎识别较难
- 会产生很多页面，难以管理

### 从地址栏输入地址到浏览器打开页面都发生了什么？

1. 输入URL之后，浏览器解析URL拿到协议、主机名、端口号、路径等信息，然后构建一个http请求
2. 浏览器访问DNS服务器解析主机名，获得ip地址（[DNS查询步骤](#DNS解析步骤是什么？)）
3. TCP链接（三次握手）（[三次握手步骤](#HTTP为什么要三次握手？都发生了什么？)）
4. HTTP请求
5. 服务器处理请求并返回数据
6. 浏览器解析并渲染数据（[渲染原理](#浏览器解析渲染的原理是什么？)）
7. 断开连接（四次握手）（[四次握手（挥手）步骤](#什么是四次握手（挥手）？)）

> 6、7顺序不一定，比如keep-alive的情况

## CSS

### 讲一下对CSS3盒模型的理解

CSS3的盒模型分两种：标准盒模型和IE盒模型

盒模型分四部分构成：content、border、margin、padding

标准盒模型的width与height不包含border、padding、margin，而IE盒模型包含border和padding不包含margin

css中的box-sizing属性可以修改盒模型，值为border-box时使用IE盒模型，值为content-box时使用标准盒模型

### DOM之间的空白间隔是什么？需要怎么解决？

是换行符等空白字符被浏览器渲染成了一个空格。

解决方法：

1. 写代码的时候不换行。与习惯差异较大，且不美观
2. 增加`float: left`。不是所有的情况都可以用float
3. 给父元素设置`font-size: 0`。有的浏览器限制了最小font-size导致不生效
4. 给父元素设置`letter-spacing: -8px`。因为子元素会继承，需要给子元素设置`letter-spacing: normal`

### CSS3 新特性都有哪些？

- 新增选择器：`div:not(.red){}` `a[attr='a']{}`等
- 边框：border-radius、box-shadow、border-image
- 背景：background-image、background-origin
- 文本：text-shadow、word-wrap
- 字体：@font-face{}
- 变化：transform 的 translate rotate scale skew
- 过度：transition
- 动画：@keyframe{}

### CSS如何优化性能？

- css压缩，减小文件体积
- 减少使用批量值，例如margin 换成 margin-top
- 减少使用@important，尽量使用link，可以在文档加载完之前就开始加载
- 减少无关规则的使用
- 尽量避免*选择器
- 降低选择器深度
- 使用继承的属性
- 谨慎使用float和position
- 尽量减少回流和重绘
- 属性0时不加单位
- 省略小数点前的0
- 雪碧图
- 使用正确的display对应的属性，比如inline的height
- 优化自定义字体
- 使用class减小css文件体积
- css与文档分离

### CSS如何减少回流、重绘

- 回流（reflow）：一旦元素的位置、大小等发生变化时，浏览器会进行的操作
- 重绘（repaint）：一旦元素节点的是否可见切换了，浏览器需要重新绘制像素点的操作

方法：

1. 减少操作时的css修改，使用class替代
2. 批量操作DOM，在计算的最后一步处理操作
3. 使用 absolute、fixed等脱离文档流
4. 开启GPU加速，使用translate等属性，可以避免reflow

### 讲一下对BFC的理解

Block formatting context，即块级格式化上下文，BFC是一个独立的布局环境，可以理解为一个容器，其中的元素按照规则进行摆放，且不影响外部布局，两个BFC之间分别独立。具体的规则是：

- 垂直方向自上而下排布
- 上下两个容器margin会重叠
- BFC之间互不影响，且容器内不影响外部元素
- 计算高度时，需要计算浮动元素的高度
- BFC不会与浮动的容器重叠
- 每个元素的左margin与容器的左border相接触

BFC解决了以下问题：

- margin重叠：两个BFC之间互不影响，所以margin就不会重叠
- 解决高度塌陷：子元素float之后，父元素高度塌陷，设置父元素是BFC即可解决
- 创建自适应两栏布局：左边宽度固定，右边宽度自适应

BFC使用：

- body自带
- float：left、right
- position：absolute、fixed
- display：inline-block、flex、table-cell、table-caption等
- overflow：hidden、auto、scroll

### transition和animation的区别

- transition是过度属性，需要触发事件，不会自执行
- animation是动画属性，可以周期性自执行

### 对requestAnimationframe等理解

requestAnimationframe 是动画请求帧，功能类似于setIntervel，但原理是在浏览器进行重绘的时候，增加一个回调函数。
和 clearInterval 类似，也有一个清理方法 clearAnimationFrame。

相比setInterval可能出现的卡顿掉帧情况，requestAnimationFrame相当于自动填写了周期时长（大概1000ms/60hz约等于16.7ms），因为在元素隐藏的时候，避免了回调的执行，相对的减少了dom操作、减少CPU占用，在函数截流等应用下有好处，且因为setInterval在异步队列中，必须要等主线执行完才开始，所以相对较晚执行。

### css省略

```css
.sl{
   overflow: hidden;
   text-overflow: ellipsis;
   white-space: nowarp;
}
.sl-2{
   overflow: hidden;
   text-overflow: ellipsis;
   display: -webkit-box;
   -webkit-box-orient: vertical;
   -webkit-line-clamp: 2;
}
```

### 讲一下常用的css单位

- 像素px：代表最小显示区域，css像素代表一个抽象的相对的单位，物理像素则是设备真实的最小显示区域
- %：相对于父元素的比例
- em：当前元素font-size的倍数
- rem：根元素font-size的倍数
- vw/vh：分别是屏幕的百分之多少
- vmin/vmax：vw/vm中的较小/大值

移动端适配更推荐rem/vw/vh配合实现

### 如何实现三栏布局

左右两栏固定，中间自适应。下面共7种方法均可实现。

```css
/* 公共 */
.outer{background: black;height:100px;}
.left{background: tomato;width:100px;height:100px;}
.right{background: gold;width:200px;height:100px;}
.center{background: lightgreen;height:100px}
/* 绝对定位1 */
.outer{position: relative;}
.left{position: absolute;}
.right{position:absolute;right:0;top:0;}
.center{margin: 0 100px;}
/* 绝对定位2 */
.outer{position: relative;}
.left{position: absolute;}
.right{position:absolute;right:0;top:0;}
.center{position:absolute;left:100px;right:100px;top:0;}
/* flex */
.outer{display:flex;}
.center{flex:1}
/* float: center需要放在right后面 */
.left{float:left}
.right{float: right}
.center{margin: 0 200px 0 100px;}
/* float 圣杯布局  */
.outer{padding: 0 200px 0 100px;}
.left{float:left;margin-left: -100px;}
.right{float: left;margin-right: -200px;}
.center{float: left;width: 100%;}
/* float 双飞翼布局 需要给center包一个div */
.left{float:left;margin-right: -100px;}
.right{float: left;margin-left: -200px;}
.center-box{float: left;width: 100%;}
.center{margin: 0 200px 0 100px;}
/* grid */
.outer{display: grid;grid-template-rows:100px;grid-template-columns: 100px auto 200px;grid-gap: 0;}
```

### 1px问题是什么？怎么解决？

1px时在Retina屏幕上，显示1px比较粗，不像1px的情况。因为 像素倍率 = 设备物理像素 / css像素÷÷÷，浏览器中有window.devicePixelRatio属性，当值大于1时，相当于实际像素被放大了。

解决办法：

1. 直接写0.5px。兼容性很差：ios8+、安卓不兼容
2. 先放大再用transform缩小。兼容性强，代码多
3. view-port整体缩放页面。整体缩放就需要考虑其他dom、资源等的展示效果，比较麻烦

```html
<meta name="view-port" content="initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5, user-scalable=no">
```

## JavaScript

### js的基本类型都有哪些，分别介绍一下

js中共有8种类型，分别是 Undefined、Null、Number、Array、Object、String、Symbol、BigInt。

Null表示空对象，一般用作初始化；Undefined表示未定义，一般用在声明未赋值。

Symbol和BigInt是ES6新增的两种，Symbol类似于uuid，解决全局变量冲突问题，使用`Symbol()`函数创建；BigInt用来解决Number有范围限制的情况，使用`102n`以n结尾的数字创建。

获取数据类型的方法有以下几种：

1. typeof a，存在一个问题是获取Array、Object、Null时都会返回object
2. a instanceof Object，这个只能判断数据的原型链是否有某一类型，无法判断数据基本类型
3. a.constructor，可以判断数据类型，但是如果对象的prototype被覆盖，则无法取到原有类型
4. **Object.toString.call(a).slice(8, -1)**，这个是最确定的方法

> 引申问题：为什么typeof null === ‘object’？  
> 答案：这是一个历史bug，因为Object的二进制的前三位是000，Null的二进制是00000000，因为前三位是预留来判断数据类型的，所以导致了这个问题

### 箭头函数和普通函数有什么区别？

除了语法简洁外，二者的区别有：

1. 箭头函数没有this，会指向上一级，且call、bind、apply都无法改变this指向
2. 箭头函数没有prototype，无法实例化，不能作为构造函数使用
3. 箭头函数没有arguments

```javascript
// 指向上级
var b = {a: ()=>{console.log(this)}} 
b.a() // Window {window: …}
// 无法修改this指向
var data = 1
var c = ()=>{console.log(this.data)}
c() // 1 this指向上级，取window.data => 1
c.call({data: 2}) // 1 this无法改变
// 无法实例化
var d = ()=>{console.log(111)}
new d() // Uncaught TypeError: d is not a constructor
// 没有arguments
var e = ()=>{console.log(arguments)}
e(1,2,3) // Uncaught ReferenceError: arguments is not defined
```

### 数组有哪些原生方法？

|方法名|参数|功能|是否改变原数组|
|-|-|-|-|
|**无源数组操作**|
|Array.from(arrlike)|传入任意可迭代对象或者有length的参数|创建一个新的数组|无原数组|
|Array.isArray(arrlike)|传入任意参数|判断是不是数组|无原数组|
|**字符串转换**|
|join(str)|传入连接字符串|把数组用字符串连接起来，返回字符串|否|
|toString()|无参数|把数组用逗号连接，返回字符串|否|
|entries()|无参数|返回Iterator，项的格式为 **[index, item]**|否|
|keys()|无参数|返回Iterator，项的格式为 **index**|否|
|**编辑源数组**|
|fill(item[, start, end])|数组项, 需要填充的区间，不填默认0～-1|用item填充/覆盖数组项|是|
|concat(arr1[... , arrN])|传入一个以上数组|连接多个数组|否|
|shift()|无参数|删除第一项，并返回|是|
|pop()|无参数|删除最后一项，并返回|是|
|unshift(item)|需要插入的项|向前插入项|是|
|push(item)|需要插入的项|向后插入项|是|
|copoyWithin(targetIndex(, start, end))|目标位置索引，被复制区间（start默认为0，end不包含在内）的索引|选择从start到end位的项复制到目标位置|是|
|**高级操作**|
|slice(start(, end))|传入起止索引|返回区间内的新数组|否|
|splice(start(, len, item1,...itemX))|开始索引，操作长度，新增的item|在原数组start位开始，选取len长度的项删除，并在start位插入items，返回被删除的数组|是|
|**循环操作**|
|findIndex((e,i)=>{})|传入方法，参数e是数组项，i是索引|按照方法规则返回符合条件的第一项的index|否|
|find((e,i)=>{})|传入方法，参数e是数组项，i是索引|按照方法规则返回符合条件的第一项|否|
|map((e,i)=>{})|传入方法，参数e是数组项，i是索引|按照方法格式化数组的每一项，返回格式化后的数组|否|
|forEach((e,i)=>{})|传入方法，参数e是数组项，i是索引|循环遍历数组|否|
|filter((e,i)=>{})|传入方法，参数e是数组项，i是索引|按照规则返回每项都符合条件的新数组|否|
|reduce((sum, e)=>{})|传入方法，参数e是数组项，sum是上一步操作累加值|累加器|否|
|reduceRight((sum, e)=>{})|传入方法，参数e是数组项，sum是上一步操作累加值|反序累加器|否|
|**判断操作**|
|some((e,i)=>{})|传入方法，参数e是数组项，i是索引|按照项是否有符合规则的，返回true/false|否|
|every((e,i)=>{})|传入方法，参数e是数组项，i是索引|按照项是否全部符合规则，返回true/false|否|
|includes(item)|传入任意参数|判断数组中是否包含该项|否|
|indexOf(item)|传入任意参数|判断数组中是否包含该项，并返回第一个符合的索引|否|
|lastIndexOf(item)|传入任意参数|**反序**判断数组中是否包含该项，并返回第一个符合的索引|否|
|**排序**|
|sort((a,b)=>{})|传入方法，a、b是项，返回一个数值|根据返回的数值是正（顺序）、负（反序）来操作原数组|是|
|reverse()|没有参数|反序原数组|是|

> 引申问题：  
> slice、splice比较相似，可能会考二者区别  
> 数组循环操作都有哪些方法？

### 位运算符都有哪些，分别是什么功能？

位运算符是把参数值转换为二进制字符串后再做运算的行为

& 与运算、 | 或运算、^ 异或运算、～ 取反、<< 左移、>> 右移

### 手写一个ajax函数

```javascript
// 回调版
function ajax(options){
   const {url, type, data, success, error} = options
   const xhr = new XMLHttpRequest();
   xhr.open(type, url, true)
   xhr.onreadaystatechange = function(){
      if(this.readyState != 4) return
      if(this.status === 200){
         success(this.response)
      }else{
         error(this.statusText)
      }
   }
   xhr.onerror = function(){
      error(this.statusText)
   }
   xhr.reponseType = 'json'
   xhr.setRequestHeader("Accept", "application/json")
   xhr.send(data)
}
// promise版
function promiseAjax(options){
   const {url, type, data} = options
   return new Promise(function(res, rej){
      const xhr = new XMLHttpRequest();
      xhr.open(type, url, true)
      xhr.onreadaystatechange = function(){
         if(this.readyState != 4) return
         if(this.status === 200){
            res(this.response)
         }else{
            rej(new Error(this.statusText))
         }
      }
      xhr.onerror = function(){
         rej(new Error(this.statusText))
      }
      xhr.reponseType = 'json'
      xhr.setRequestHeader("Accept", "application/json")
      xhr.send(data)
   })
}
```

### 常用的请求的方法都有哪些，区别是什么

原生有两种，分别是ajax（XMLHttpRequest）、fetch（ES6新增的使用promise的原生api）

此外还有封装的第三方库 axios（用promise封装的ajax）等

### 什么是尾调用？尾调用有什么好处

尾调用是在函数执行到最后一步调用了另一个函数（return func写在中间也支持），是js自带的优化功能，在ES6中 只有在严格模式下启用。

函数调用是会保留当前函数中的上下文环境，会占用一定内存，调用的层数较多时，性能影响较大，如果函数最后一句调用其他函数，js就不会缓存上下文环境，直接去执行，相当于节省了内存。

递归中也可以使用尾调用，防止递归中出现内存溢出的情况。

### 讲一下你对原型、原型链的理解

js中包含普通对象和函数对象，所有的对象上都有 **\_\_proto__** 属性，但是只有函数对象有 **prototype**：构造函数就是函数对象，构造函数实例化后的对象就是普通对象。

构造函数有 **prototype** 属性，这个属性指向了调用该构造函数时创建的**实例的原型**；构造函数实例化后的对象有 **\_\_proto__** 属性，这个属性指向了**该对象的原型**；所以连起来就是：构造函数的prototype属性和实例化对象的\_\_proto__属性相等，即**实例的原型**。

**prototype** 参数除了手动绑定的参数外，还包含了**constructor**属性，prototype.constructor指向构造函数本身。 实例化对象的 constructor 属性同样指向构造函数本身。

因为在实例获取属性时如果没有，就会查找原型上的属性，万一原型上没有，就会查找原型的原型，因为原型可以无限层数的实例化，这样形成的链就是原型链。

总结来说：

原型(prototype)是查看当前对象是由哪个构造函数实例化出来的

原型链(\_\_proto__)是一级级地向上层查看实例化原型

> 引申问题：原型链的终点是什么？  
> 所有构造函数都指向Object，所以原型链的末端指向 Object.prototype.\_\_proto__ 即为 null

### 讲一下你对闭包对理解

概念：闭包是指可以访问另一个函数作用域内变量的函数

功能：创建私有变量，保留变量的内存占用

### 讲一下你对this对象对理解

this是执行上下文的一个属性，指向最后一次调用这个方法的对象。判断具体指向的对象可以根据以下优先级来（从高到低）：

1. 构造函数：实例化时创建了对象，this指向这个变量
2. apply、call、bind：根据语法绑定this到第一个参数上
3. 方法调用：如果一个函数作为一个对象的方法被调用时，this指向这个对象
4. 函数调用：函数被直接调用时，this指向全局对象

### 垃圾回收机制都有哪些方式？

### js是如何体现面对对象的特性的？

### 异步函数怎么使用？都有哪些方法？

## 网络通信

### DNS解析步骤是什么？

1. 浏览器缓存（浏览器会在缓存里查询有没有主机名对应的ip，查不到就下一步）
2. 系统缓存（同上，系统中查不到对应的ip就下一步）
3. 路由器缓存（同上，路由器中查不到对应的ip就下一步）
4. ISP DNS缓存（去 网络提供商 的DNS缓存服务器中查找，大概率不会走到下一步）
5. 递归搜索（ISP的DNS服务器开始从root域名服务器开始递归）（如果还没大概率是没有这个网站）

（[返回 -> 从地址栏输入地址到浏览器打开页面都发生了什么？](#从地址栏输入地址到浏览器打开页面都发生了什么？)）

### HTTP为什么要三次握手？都发生了什么？

原因：这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。

- 第一次握手，客户端发送一个数据包给服务端，确认客户端的发送能力
- 第二次握手，服务端返回一个数据包给客户端，确认服务端的接收能力和发送能力
- 第三次握手，客户端再回传一个数据包，客户端通知服务端准备发送数据

（[返回 -> 从地址栏输入地址到浏览器打开页面都发生了什么？](#从地址栏输入地址到浏览器打开页面都发生了什么？)）

### 什么是四次握手（挥手）？

HTTP的连接需要TCP三次握手，而关闭连接则需要TCP四次挥手

- 第一次挥手，客户端发送给服务端，请求报文已经发送完毕，准备关闭
- 第二次挥手，服务端发起，请求报文已经接受完毕，准备关闭
- 第三次挥手，服务器发起，响应报文已经发送完毕，可以关闭
- 第四次挥手，客户端发起，响应报文接收完毕，可以关闭

第二、三次挥手不一起发送的原因是：第一次握手后服务器知道客户端不再发送数据但还能接收数据，所以自己可以立即关闭 也可以发送数据后再关闭连接，因此确认（步骤2）和关闭（步骤3）是分开的。

（[返回 -> 从地址栏输入地址到浏览器打开页面都发生了什么？](#从地址栏输入地址到浏览器打开页面都发生了什么？)）

## 前端安全

### 浏览器解析渲染的原理是什么？

1. 解析HTML，构建DOM树
2. 解析CSS，生成CSSOM规则树
3. 根据解析的DOM树和CSSOM树，构建render树
   - render树的节点就是渲染对象，
   - 渲染对象是一个包含颜色大小等属性的矩形，根据CSSOM规则，不可见节点不会插入到渲染树中
4. 布局阶段，render树自动重排阶段，根据渲染树来调整元素的定位、尺寸、布局
   - 回流，Reflow，当元素的内容、结构、位置尺寸发生变化时再次布局
5. 绘制阶段，浏览器遍历渲染树冰调用渲染对象的paint方法，绘制具体像素
   - 重绘，Repaint，当元素的颜色等改变时，再次绘制元素

（[返回 -> 从地址栏输入地址到浏览器打开页面都发生了什么？](#从地址栏输入地址到浏览器打开页面都发生了什么？)）

## 性能优化

## Vue

## React

## 框架、插件
